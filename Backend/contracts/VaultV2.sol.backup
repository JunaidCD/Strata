// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @dev Interface for Aave Pool contract
 */
interface IPool {
    function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;
    function withdraw(address asset, uint256 amount, address to) external returns (uint256);
}

/**
 * @title Vault v2
 * @dev Vault contract with Aave integration for real yield generation
 * Deposits USDC into Aave to earn yield via aUSDC
 * Only accepts USDC, tracks user deposits, allows full withdrawals
 * No fees, no governance, single strategy (Aave only)
 */
contract VaultV2 is ReentrancyGuard {
    IERC20 public usdcToken;
    IERC20 public aUsdcToken;
    IPool public aavePool;
    
    // Mapping to track deposited balance per user (principal only)
    mapping(address => uint256) public userBalances;
    
    // Events for tracking deposits and withdrawals
    event Deposited(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    
    /**
     * @dev Constructor takes USDC token address and Aave Pool address
     * @param _usdcToken Address of the USDC ERC20 token
     * @param _aavePool Address of the Aave Pool contract
     */
    constructor(address _usdcToken, address _aavePool) {
        usdcToken = IERC20(_usdcToken);
        aavePool = IPool(_aavePool);
        
        // aUSDC address on Sepolia (this is the interest-bearing USDC token)
        aUsdcToken = IERC20(0x5414bD0882B4646B5A778350B1c84AB69e627735);
    }
    
    /**
     * @dev Deposit USDC into vault and immediately supply to Aave
     * User must approve vault to spend their USDC first
     * @param amount Amount of USDC to deposit (in wei, 6 decimals for USDC)
     */
    function deposit(uint256 amount) external nonReentrant {
        require(amount > 0, "Amount must be greater than 0");
        
        // Pull USDC from user to vault using transferFrom
        bool success = usdcToken.transferFrom(msg.sender, address(this), amount);
        require(success, "USDC transfer failed");
        
        // Update user balance (track principal only)
        userBalances[msg.sender] += amount;
        
        // Approve Aave Pool to spend USDC
        usdcToken.approve(address(aavePool), amount);
        
        // Supply USDC to Aave to receive aUSDC
        aavePool.supply(address(usdcToken), amount, address(this), 0);
        
        emit Deposited(msg.sender, amount);
    }
    
    /**
     * @dev Withdraw all deposited USDC plus accrued yield
     * Only allows full withdrawal of user's entire balance
     * Withdraws from Aave, returns USDC + yield to user
     */
    function withdraw() external nonReentrant {
        uint256 principal = userBalances[msg.sender];
        require(principal > 0, "No balance to withdraw");
        
        // Reset user balance to prevent reentrancy
        userBalances[msg.sender] = 0;
        
        // Calculate total aUSDC to withdraw (user's share of total aUSDC)
        uint256 totalAUsdcBalance = aUsdcToken.balanceOf(address(this));
        uint256 totalPrincipal = getTotalDeposited();
        
        // User's proportional share of aUSDC
        uint256 userAUsdcShare = (principal * totalAUsdcBalance) / totalPrincipal;
        
        // Withdraw USDC from Aave (this will return USDC + accrued yield)
        uint256 usdcReceived = aavePool.withdraw(address(usdcToken), userAUsdcShare, address(this));
        
        // Transfer all received USDC to user
        bool success = usdcToken.transfer(msg.sender, usdcReceived);
        require(success, "USDC transfer failed");
        
        emit Withdrawn(msg.sender, usdcReceived);
    }
    
    /**
     * @dev Get user's current deposited principal balance
     * @param user Address of the user
     * @return User's deposited USDC principal (not including yield)
     */
    function getUserBalance(address user) external view returns (uint256) {
        return userBalances[user];
    }
    
    /**
     * @dev Get total principal deposited by all users
     * @return Total principal amount deposited
     */
    function getTotalDeposited() public view returns (uint256) {
        // This is a simplified calculation - in production, you might want to track this separately
        // For now, we'll use the contract's USDC balance as a proxy (excluding any pending operations)
        return usdcToken.balanceOf(address(this));
    }
    
    /**
     * @dev Get total value held in vault (aUSDC balance represents principal + yield)
     * @return Total value in USDC terms (principal + accrued yield)
     */
    function getTotalValue() external view returns (uint256) {
        return aUsdcToken.balanceOf(address(this));
    }
    
    /**
     * @dev Get user's withdrawable balance (principal + accrued yield)
     * @param user Address of the user
     * @return User's total withdrawable amount in USDC
     */
    function getUserWithdrawableBalance(address user) external view returns (uint256) {
        uint256 principal = userBalances[user];
        if (principal == 0) return 0;
        
        uint256 totalAUsdcBalance = aUsdcToken.balanceOf(address(this));
        uint256 totalPrincipal = getTotalDeposited();
        
        // User's proportional share of total value
        return (principal * totalAUsdcBalance) / totalPrincipal;
    }
    
    /**
     * @dev Get user's accrued yield (total value - principal)
     * @param user Address of the user
     * @return User's accrued yield in USDC
     */
    function getUserYield(address user) external view returns (uint256) {
        uint256 withdrawable = getUserWithdrawableBalance(user);
        uint256 principal = userBalances[user];
        
        if (withdrawable > principal) {
            return withdrawable - principal;
        }
        return 0;
    }
}
